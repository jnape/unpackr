{"name":"Unpackr","tagline":"DSL for making working with byte-arrays palatable in Clojure","body":"unpackr [![Build Status](https://travis-ci.org/jnape/unpackr.png?branch=master)](https://travis-ci.org/jnape/unpackr)\r\n=======\r\n\r\nA DSL for making working with byte-arrays palatable in Clojure\r\n\r\ninstallation\r\n------------\r\n\r\nAdd the following dependency to your `project.clj` file:\r\n\r\n    [unpackr \"0.1.0-SNAPSHOT\"]\r\n\r\nexamples\r\n--------\r\n\r\nExtract a signed short, followed by an unsigned int, followed by the remaining bytes from a byte array:\r\n\r\n```clojure\r\n; The normal way\r\n(let [buffer (java.nio.ByteBuffer/wrap (byte-array (map byte (range 100))))]\r\n  (let [a (.getShort buffer) b (bit-and (.getInt buffer) 0x00000000FFFFFFFF) c (byte-array (.remaining buffer))]\r\n    (.get buffer c)\r\n    [a b c]))\r\n\r\n; Using unpackr\r\n(unpack [:short :uint :rest] (as-bytes (range 100)))\r\n```\r\n\r\nExtract an unsigned short, followed by that many bytes ahead, followed by an unsigned byte:\r\n\r\n```clojure\r\n; The normal way\r\n(let [buffer (java.nio.ByteBuffer/wrap (byte-array (map byte (range 100))))]\r\n  (let [a (bit-and (.getShort buffer) 0x0000FFFF) b (byte-array a)]\r\n    (.get buffer b)\r\n    [a b (bit-and (.get buffer) 0x00FF)]))\r\n\r\n; Using unpackr\r\n(unpack-let [a :ushort more :rest] (as-bytes (range 100))\r\n  (unpack-let [b a c :ubyte] more\r\n    [a b c]))\r\n```\r\n\r\ndocumentation\r\n-------------\r\n\r\nThe full API documentation of unpackr can be found at http://www.jnape.com/code/unpackr\r\n\r\nlicense\r\n-------\r\n\r\nunpackr is distributed under the [Eclipse Public License](http://choosealicense.com/licenses/eclipse/), the same as Clojure.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}