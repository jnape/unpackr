{"name":"Unpackr","tagline":"DSL for making working with byte-arrays palatable in Clojure","body":"unpackr\r\n=======\r\n\r\nA DSL for making working with byte-arrays palatable in Clojure\r\n\r\nusage\r\n-----\r\n\r\nunpackr is distributed through clojars, and can be included in your project's ```:dependencies``` as ```[unpackr \"0.1.0-SNAPSHOT\"]```\r\n\r\nexamples\r\n--------\r\n\r\nExtract a signed short, followed by an unsigned int, followed by the remaining bytes from a byte array:\r\n\r\n```clojure\r\n; The normal way\r\n(let [buffer (java.nio.ByteBuffer/wrap (byte-array (map byte (range 100))))]\r\n  (let [a (.getShort buffer) b (bit-and (.getInt buffer) 0x00000000FFFFFFFF) c (byte-array (.remaining buffer))]\r\n    (.get buffer c)\r\n    [a b c]))\r\n\r\n; Using unpackr\r\n(unpack [:short :uint :rest] (as-bytes (range 100)))\r\n```\r\n\r\nExtract an unsigned short, followed by that many bytes ahead, followed by an unsigned byte:\r\n\r\n```clojure\r\n; The normal way\r\n(let [buffer (java.nio.ByteBuffer/wrap (byte-array (map byte (range 100))))]\r\n  (let [a (bit-and (.getShort buffer) 0x0000FFFF) b (byte-array a)]\r\n    (.get buffer b)\r\n    [a b (bit-and (.get buffer) 0x00FF)]))\r\n\r\n; Using unpackr\r\n(unpack-let [a :ushort more :rest] (as-bytes (range 100))\r\n  (unpack-let [b a c :ubyte] more\r\n    [a b c]))\r\n```\r\n\r\ndocumentation\r\n-------------\r\n\r\nThe full API documentation of unpackr can be found at http://www.jnape.com/code/unpackr","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}